# monitoring/logstash/pipeline/logstash.conf
input {
  # TCP input for application logs
  tcp {
    port => 5000
    codec => json_lines
    tags => ["application"]
  }
  
  # Beats input for Docker logs
  beats {
    port => 5044
    tags => ["docker"]
  }
  
  # HTTP input for webhook logs
  http {
    port => 8080
    codec => json
    tags => ["webhook"]
  }
}

filter {
  # Parse JSON logs
  if [message] =~ /^\{.*\}$/ {
    json {
      source => "message"
      target => "parsed"
    }
  }
  
  # Extract Spring Boot log patterns
  if [app_name] {
    grok {
      match => {
        "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:log_level} %{NUMBER:pid} --- \[%{DATA:thread}\] %{DATA:logger} : %{GREEDYDATA:log_message}"
      }
    }
  }
  
  # Add environment metadata
  mutate {
    add_field => {
      "environment" => "${ENVIRONMENT:dev}"
      "cluster" => "perpustakaan-microservices"
    }
  }
  
  # Parse timestamp
  if [timestamp] {
    date {
      match => ["timestamp", "ISO8601"]
      target => "@timestamp"
    }
  }
  
  # Extract service name from container
  if [container] and [container][name] {
    mutate {
      add_field => { "service_name" => "%{[container][name]}" }
    }
  }
  
  # Classify log level
  if [log_level] {
    mutate {
      lowercase => ["log_level"]
    }
  }
  
  # Extract error stack traces
  if [log_level] == "error" and [log_message] =~ /Exception/ {
    mutate {
      add_tag => ["has_exception"]
    }
    
    grok {
      match => {
        "log_message" => "(?<exception_type>[a-zA-Z.]+Exception): (?<exception_message>.*)"
      }
    }
  }
  
  # Parse HTTP access logs
  if [message] =~ /HTTP/ {
    grok {
      match => {
        "message" => "%{IPORHOST:client_ip} %{USER:ident} %{USER:auth} \[%{HTTPDATE:timestamp}\] \"%{WORD:http_method} %{DATA:http_request} HTTP/%{NUMBER:http_version}\" %{NUMBER:http_status} %{NUMBER:bytes}"
      }
    }
  }
  
  # GeoIP for client IPs
  if [client_ip] {
    geoip {
      source => "client_ip"
      target => "geoip"
    }
  }
  
  # Remove unnecessary fields
  mutate {
    remove_field => ["host", "agent", "ecs", "input"]
  }
}

output {
  # Output to Elasticsearch
  elasticsearch {
    hosts => ["${ELASTICSEARCH_HOSTS:elasticsearch:9200}"]
    index => "perpustakaan-%{[service_name]:unknown}-%{+YYYY.MM.dd}"
    
    # Use document ID to avoid duplicates
    document_id => "%{[@metadata][fingerprint]}"
    
    # Template for index
    template_name => "perpustakaan-logs"
    template_overwrite => true
  }
  
  # Output errors to separate index
  if [log_level] == "error" or "error" in [tags] {
    elasticsearch {
      hosts => ["${ELASTICSEARCH_HOSTS:elasticsearch:9200}"]
      index => "perpustakaan-errors-%{+YYYY.MM.dd}"
    }
  }
  
  # Output to stdout for debugging (can be disabled in production)
  stdout {
    codec => rubydebug {
      metadata => true
    }
  }
}
